# read.csv.sql
install.packages('googleVis')
# read.csv.sql
install.packages('googleVis')
install.packages('googleVis')
install.rtools(f,f)
install.packages('googleVis')
install.packages('googleVis')
library()
install.packages('googleVis')
install.packages(c('googleVis')
install.packages(c('googleVis')
install.rtools(f,f)
install.packages(c('googleVis')
install.packages('googleVis')
install.packages('googleVis')
install.packages('googleVis')
# 연습문제
#1. 구구단
for (i in 2:9) {
line <- str_c(i, '단')
print(line)
for (k in 1:9) {
line <- str_c(i, ' * ', k, ' = ', i*k)
print(line)
}
}
# 연습문제
#1. 구구단
library(stringr)
for (i in 2:9) {
line <- str_c(i, '단')
print(line)
for (k in 1:9) {
line <- str_c(i, ' * ', k, ' = ', i*k)
print(line)
}
}
for (i in 2:9) {
x <- paste(i, '단')
print(x)
}
for (i in 2:9) {
x <- paste(i, '단')
print(x)
for(k in 1:9) {
x <- print(paste(i, '*', K, '=', i*l))
}
}
for (i in 2:9) {
x <- paste(i, '단')
print(x)
for(k in 1:9) {
x <- paste(i, '*', K, '=', i*l)
print(x)
}
}
for (i in 2:9) {
x <- paste(i, '단')
print(x)
for(k in 1:9) {
x <- paste(i, '*', K, '=', i*k)
print(x)
}
}
for (i in 2:9) {
x <- paste(i, '단')
print(x)
for(k in 1:9) {
x <- paste(i, '*', K, '=', i*k)
print(x)
}
}
for (i in 2:9) {
x <- paste(i, '단')
print(x)
for(k in 1:9) {
x <- paste(i, '*', k, '=', i*K)
print(x)
}
}
for (i in 2:9) {
line <- str_c(i, '단')
print(line)
for (k in 1:9) {
line <- str_c(i, ' * ', k, ' = ', i*k)
print(line)
}
}
for (i in 2:9) {
line <- paste(i, '단')
print(line)
for(k in 1:9) {
line <- paste(i, '*', k, '=', i*K)
print(line)
}
}
for (i in 2:9) {
line <- paste(i, '단')
print(line)
for(k in 1:9) {
line <- paste(i, '*', k, '=', i*k)
print(line)
}
}
for (i in 2:9) {
line <- paste(i, '단')
print(line)
for(k in 1:9) {
line <- paste(i, '*', k, '=', i*k)
print(line)
}
}
for(i in 2:9) {
print(i)
}
for(i in 2:9) {
gugudan <- paste(i, '단')
print(i)
}
for(i in 2:9) {
gugudan <- paste(i, '단')
print(gugudan)
}
for(i in 2:9) {
gugudan <- paste(i, '단')
print(gugudan)
for(k in 1:9) {
ggg <- paste(i, '*', k, '=', i*k)
print(ggg)
}
}
gg <- function(x) {
for(i in 2:9) {
gugudan <- paste(i, '단')
print(gugudan)
for(k in 1:9) {
ggg <- paste(i, '*', k, '=', i*k)
print(ggg)
}
}
}
gg(1)
while (T) {
for (i in 1:4) {
line <- ''
if (i != 4) {
for (k in 1:(3 - (i - 1)))
line <- str_c(line, ' ')
}
for (k in 1:(2*i - 1))
line <- str_c(line, '#')
print(line)
}
for (i in 3:1) {
line <- ''
for (k in 1:(3 - (i - 1)))
line <- str_c(line, ' ')
for (k in 1:(2*i - 1))
line <- str_c(line, '#')
print(line)
}
break;
}
d <- paste(!)
while(w<4) {
d <- paste(!)
print(d)
}
while(w<4) {
d <- w
print(d)
}
print(w)
while(w<4) {
print(w)
}
w <- 0
while(w<4) {
print(w)
}
women
women
plot(weight ~ height, data = women)
fit <- lm(weight ~ height, data = women)
abline(fit, col = 'red')
summary(fit)
cor.test(women$weight, women$height)
par(mfrow = c(2,2))
plot(fit)
fit2 <- lm(weight ~ height + I(height^2), data = women)
summary(fit2)
par(mfrow = c(1,1))
plot(fit2)
par(mfrow = c(1,1))
plot(weight ~ height, data = women)
lines(women$height, fitted(fit2), col='green')
par(mfrow= c(2,2))
plot(fit2)
fit3 <- lm(weight ~ height + I(height^2) + I(height^3), data = women)
fit3 <- lm(weight ~ height + I(height^2) + I(height^3), data = women)
par(mfrow= c(2,2))
plot(fit3)
summary(fit3)
summary(fit2)
### 31. 다중회귀분석
states.x77
### 31. 다중회귀분석
state.x77
states <- as.data.frame(state.x77[,c('Murder', 'Population', 'Illiteracy', 'Income', 'Frost')])
head(states)
fit <- lm(Murder ~ Population + Illiteracy + Income + Frost, data = states)
summary(fit)
# 검증을 먼저 한다.
# 다중공선성(multicolinearity)
install.packages('car', dependencies = T)
library(car)
# VIF 검정을 먼저해서 sqrt(vif) > 2면 제외 시킨다.
vif(fit)
sqrt(vif(fit))
### 31. 이상관측치
par(mfrow = c(1,1))
influencePlot(fit, id.method = 'identity')
influencePlot(fit, id.method = 'identity')
influencePlot(fit, id.method = 'identity')
### 33. 회귀모형의 교정
states
fit
summary(fit)
summary(fit)
par(mfrow = c(2,2))
plot(fit)
powerTransform(states$Murder)
summary(powerTransform(states$Murder))
# 2) 선형성을 만족하지 않았을 때
boxTidwell(Murder ~ Population + Illiteracy, data = states)
# 2) 선형성을 만족하지 않았을 때
boxTidwell(Murder ~ Population + Illiteracy, data = states)
# 2) 선형성을 만족하지 않았을 때
boxTidwell(Murder ~ Population + Illiteracy, data = states)
# 3) 등분산성을 만족하지 않았을 때
ncvTest((fit))
spreadLevelPlot(fit)
### 32. 이상관측치 검정
par(mfrow = c(1,1))
spreadLevelPlot(fit) # 등분산성을 하지 않았다면 1.2096배 하면 된다.(제안)
### 34. 예측 변수 선택
fit1 <- lm(Murder ~., data=states)
summary(fit1)
# Income, Frost의 p_value가 높으니 한번 빼보자
fit2 <- lm(Murder ~ Population + Illiteracy, data=states)
summary(fit2)
# 이런 경우의 수는 많아서 가장 좋은 회귀모델을 만들기 위해 AIC를 이용
AIC(fit1, fit2)
# stepwise regression (Backward stepwise regression, Forward stepwise regression)
# Backward stepwise regression
# 모든 변수들을 모두 포함시키는 풀 모델을 만들고
# p_value가 적은 값을 빼면서 AIC값이 감소하는지 증가하는지 검사를 함.
full.model <- lm(Murder~., data=states)
reduced.model <- step(full.model, direction = 'backward')
summary(reduced.model)
# forward stepwise regression
# P_value가 가장 높은 변수를 추가하면서 AIC값이 감소하는지 증가하는지 검사를 함.
min.model = lm(Murder~1, data = states)
fwd.model <- step(min.model, direction = 'forward',
scope = Murder ~Population + Illiteracy + Income + Frost), trace=0
fwd.model <- step(min.model, direction = 'forward',
scope = (Murder ~Population + Illiteracy + Income + Frost), trace=0)
summary(fwd.model)
# all subset regression
install.packages('leaps')
library(leaps)
leaps <- regsubsets(Murder ~. ,
data = states,
nbest = 4)
plot(leaps, scale = 'adjr2')
summary(leaps)
leaps <- regsubsets(Murder ~ Population + Illiteracy + Income _ Frost ,
data = states,
nbest = 4)
leaps <- regsubsets(Murder ~ Population + Illiteracy + Income + Frost,
data = states,
nbest = 4)
plot(leaps, scale = 'adjr2')
plot(leaps, scale = 'adjr2')
setwd('D:/Heechul/R_Data_Analysis/Lecture/Kkamsin')
